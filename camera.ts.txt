// camera.ts - Camera System with Smooth Following and Zoom
import { Vector2 } from ‘./basic_classes’;
import { GameConfig } from ‘./game_config’;

export interface CameraTarget {
position: Vector2;
velocity?: Vector2;
}

export class Camera {
public position: Vector2;
public zoom: number;
public rotation: number;

```
private target: CameraTarget | null = null;
private targetPosition: Vector2;
private smoothing: number;
private maxSpeed: number;
private deadZone: number;
private predictiveFollowing: boolean;
private shakeIntensity: number;
private shakeDecay: number;
private shakeOffset: Vector2;

// Zoom constraints
private minZoom: number;
private maxZoom: number;
private zoomSpeed: number;
private targetZoom: number;

// Scene transition support
private transitionState: 'none' | 'zooming_out' | 'zooming_in' = 'none';
private transitionCallback: (() => void) | null = null;

constructor() {
    this.position = new Vector2(0, 0);
    this.targetPosition = new Vector2(0, 0);
    this.zoom = 1.0;
    this.targetZoom = 1.0;
    this.rotation = 0;
    
    // Camera follow settings
    this.smoothing = 0.08;
    this.maxSpeed = 500;
    this.deadZone = 20;
    this.predictiveFollowing = true;
    
    // Screen shake settings
    this.shakeIntensity = 0;
    this.shakeDecay = 8.0;
    this.shakeOffset = new Vector2(0, 0);
    
    // Zoom settings
    this.minZoom = 0.1;
    this.maxZoom = 5.0;
    this.zoomSpeed = 2.0;
}

update(deltaTime: number): void {
    this.updateTarget(deltaTime);
    this.updateZoom(deltaTime);
    this.updateShake(deltaTime);
    this.handleSceneTransition(deltaTime);
}

private updateTarget(deltaTime: number): void {
    if (!this.target) return;

    // Calculate target position with optional prediction
    let targetPos = this.target.position.clone();
    
    if (this.predictiveFollowing && this.target.velocity) {
        const predictionFactor = 30;
        targetPos.x += this.target.velocity.x * predictionFactor;
        targetPos.y += this.target.velocity.y * predictionFactor;
    }

    this.targetPosition = targetPos;

    // Calculate distance to target
    const distance = this.position.distanceTo(this.targetPosition);

    // Only move if outside dead zone
    if (distance > this.deadZone) {
        // Smooth interpolation with speed limiting
        const factor = 1 - Math.pow(this.smoothing, deltaTime * 60);
        const moveDistance = Math.min(distance * factor, this.maxSpeed * deltaTime);
        
        const direction = this.targetPosition.subtract(this.position).normalize();
        const movement = direction.multiply(moveDistance);
        
        this.position = this.position.add(movement);
    }
}

private updateZoom(deltaTime: number): void {
    if (Math.abs(this.zoom - this.targetZoom) > 0.001) {
        const factor = 1 - Math.pow(0.1, deltaTime * this.zoomSpeed);
        this.zoom += (this.targetZoom - this.zoom) * factor;
        
        // Clamp zoom to bounds
        this.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.zoom));
    }
}

private updateShake(deltaTime: number): void {
    if (this.shakeIntensity > 0) {
        // Generate random shake offset
        const angle = Math.random() * Math.PI * 2;
        const distance = this.shakeIntensity;
        
        this.shakeOffset.x = Math.cos(angle) * distance;
        this.shakeOffset.y = Math.sin(angle) * distance;
        
        // Decay shake over time
        this.shakeIntensity = Math.max(0, this.shakeIntensity - this.shakeDecay * deltaTime);
    } else {
        this.shakeOffset.x = 0;
        this.shakeOffset.y = 0;
    }
}

private handleSceneTransition(deltaTime: number): void {
    switch (this.transitionState) {
        case 'zooming_out':
            if (this.zoom <= this.minZoom + 0.01) {
                this.transitionState = 'zooming_in';
                if (this.transitionCallback) {
                    this.transitionCallback();
                }
            }
            break;
            
        case 'zooming_in':
            if (Math.abs(this.zoom - this.targetZoom) < 0.01) {
                this.transitionState = 'none';
                this.transitionCallback = null;
            }
            break;
    }
}

// Camera control methods
setTarget(target: CameraTarget | null): void {
    this.target = target;
    if (target) {
        this.targetPosition = target.position.clone();
    }
}

followTarget(target: CameraTarget, smoothing: number = 0.08): void {
    this.target = target;
    this.smoothing = smoothing;
}

jumpToTarget(): void {
    if (this.target) {
        this.position = this.target.position.clone();
        this.targetPosition = this.position.clone();
    }
}

jumpToPosition(position: Vector2): void {
    this.position = position.clone();
    this.targetPosition = position.clone();
}

// Zoom controls
setZoom(zoom: number, instant: boolean = false): void {
    zoom = Math.max(this.minZoom, Math.min(this.maxZoom, zoom));
    
    if (instant) {
        this.zoom = zoom;
    }
    this.targetZoom = zoom;
}

zoomIn(factor: number = 1.2): void {
    this.setZoom(this.targetZoom * factor);
}

zoomOut(factor: number = 0.8): void {
    this.setZoom(this.targetZoom * factor);
}

// Screen shake effects
shake(intensity: number, duration: number = 0.5): void {
    this.shakeIntensity = Math.max(this.shakeIntensity, intensity);
    // Duration is handled by decay rate
}

// Scene transition support
transitionToScene(newZoom: number, callback: () => void): void {
    this.transitionState = 'zooming_out';
    this.transitionCallback = callback;
    this.setZoom(this.minZoom);
    
    // After callback, zoom to new target
    setTimeout(() => {
        this.setZoom(newZoom);
    }, 100);
}

// Coordinate transformations
worldToScreen(worldPosition: Vector2, screenWidth: number, screenHeight: number): Vector2 {
    const adjustedPosition = this.position.add(this.shakeOffset);
    
    return new Vector2(
        (worldPosition.x - adjustedPosition.x) * this.zoom + screenWidth / 2,
        (worldPosition.y - adjustedPosition.y) * this.zoom + screenHeight / 2
    );
}

screenToWorld(screenPosition: Vector2, screenWidth: number, screenHeight: number): Vector2 {
    const adjustedPosition = this.position.add(this.shakeOffset);
    
    return new Vector2(
        (screenPosition.x - screenWidth / 2) / this.zoom + adjustedPosition.x,
        (screenPosition.y - screenHeight / 2) / this.zoom + adjustedPosition.y
    );
}

// View frustum calculations
getViewBounds(screenWidth: number, screenHeight: number): {
    left: number,
    right: number,
    top: number,
    bottom: number,
    width: number,
    height: number
} {
    const halfWidth = (screenWidth / 2) / this.zoom;
    const halfHeight = (screenHeight / 2) / this.zoom;
    const adjustedPosition = this.position.add(this.shakeOffset);
    
    return {
        left: adjustedPosition.x - halfWidth,
        right: adjustedPosition.x + halfWidth,
        top: adjustedPosition.y - halfHeight,
        bottom: adjustedPosition.y + halfHeight,
        width: halfWidth * 2,
        height: halfHeight * 2
    };
}

isInView(position: Vector2, radius: number, screenWidth: number, screenHeight: number): boolean {
    const bounds = this.getViewBounds(screenWidth, screenHeight);
    
    return position.x + radius >= bounds.left &&
           position.x - radius <= bounds.right &&
           position.y + radius >= bounds.top &&
           position.y - radius <= bounds.bottom;
}

// Camera state queries
getEffectivePosition(): Vector2 {
    return this.position.add(this.shakeOffset);
}

isFollowingTarget(): boolean {
    return this.target !== null;
}

isShaking(): boolean {
    return this.shakeIntensity > 0;
}

isTransitioning(): boolean {
    return this.transitionState !== 'none';
}

// Configuration
setSmoothing(smoothing: number): void {
    this.smoothing = Math.max(0.001, Math.min(1.0, smoothing));
}

setMaxSpeed(maxSpeed: number): void {
    this.maxSpeed = maxSpeed;
}

setDeadZone(deadZone: number): void {
    this.deadZone = deadZone;
}

setPredictiveFollowing(enabled: boolean): void {
    this.predictiveFollowing = enabled;
}

setZoomBounds(minZoom: number, maxZoom: number): void {
    this.minZoom = Math.max(0.01, minZoom);
    this.maxZoom = Math.max(this.minZoom, maxZoom);
    
    // Clamp current zoom to new bounds
    this.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.zoom));
    this.targetZoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.targetZoom));
}

// Debug information
getDebugInfo(): any {
    return {
        position: this.position,
        targetPosition: this.targetPosition,
        zoom: this.zoom,
        targetZoom: this.targetZoom,
        shakeIntensity: this.shakeIntensity,
        hasTarget: this.target !== null,
        isTransitioning: this.isTransitioning(),
        transitionState: this.transitionState
    };
}

// Getters
get x(): number { return this.position.x + this.shakeOffset.x; }
get y(): number { return this.position.y + this.shakeOffset.y; }
get centerX(): number { return this.position.x; }
get centerY(): number { return this.position.y; }
```

}

export default Camera;