// Essential Game Classes - Simplified Implementation for Demo
import { Game } from './Game';
import { COLORS } from '../main';

// Camera System
export class Camera {
    public x: number = 0;
    public y: number = 0;
    public zoom: number = 1.0;
    private targetX: number = 0;
    private targetY: number = 0;
    private smoothing: number = 0.05;
    
    constructor(private game: Game) {}
    
    public followPlayer(player: any, deltaTime: number): void {
        // Predict player movement for smoother camera
        const predictionFactor = 30;
        this.targetX = player.position.x + player.velocity.x * predictionFactor;
        this.targetY = player.position.y + player.velocity.y * predictionFactor;
        
        // Smooth interpolation
        const factor = 1 - Math.pow(this.smoothing, deltaTime * 60);
        this.x += (this.targetX - this.x - this.game.getCanvas().width / 2) * factor;
        this.y += (this.targetY - this.y - this.game.getCanvas().height / 2) * factor;
    }
    
    public update(deltaTime: number): void {
        // Camera update logic
    }
    
    public worldToScreen(worldX: number, worldY: number): { x: number; y: number } {
        return {
            x: (worldX - this.x) * this.zoom,
            y: (worldY - this.y) * this.zoom
        };
    }
    
    public screenToWorld(screenX: number, screenY: number): { x: number; y: number } {
        return {
            x: screenX / this.zoom + this.x,
            y: screenY / this.zoom + this.y
        };
    }
}

// Scene Management
export class SceneManager {
    private currentScene: string = 'starSystem';
    private scenes: Map<string, any> = new Map();
    
    constructor(private game: Game, private galaxy: any) {
        this.scenes.set('starSystem', new StarSystemScene(this.game));
        this.scenes.set('interstellarSpace', new InterstellarSpaceScene(this.game));
    }
    
    public async initialize(): Promise<void> {
        // Initialize scenes
        for (const scene of this.scenes.values()) {
            if (scene.initialize) {
                await scene.initialize();
            }
        }
    }
    
    public getCurrentSceneName(): string {
        return this.currentScene;
    }
    
    public switchScene(sceneName: string): void {
        if (this.scenes.has(sceneName)) {
            this.currentScene = sceneName;
            console.log(`🌟 Switched to scene: ${sceneName}`);
        }
    }
    
    public update(deltaTime: number): void {
        const scene = this.scenes.get(this.currentScene);
        if (scene && scene.update) {
            scene.update(deltaTime);
        }
    }
    
    public render(ctx: CanvasRenderingContext2D, camera: Camera): void {
        const scene = this.scenes.get(this.currentScene);
        if (scene && scene.render) {
            scene.render(ctx, camera);
        }
    }
}

// Star System Scene
class StarSystemScene {
    private celestialBodies: any[] = [];
    
    constructor(private game: Game) {
        this.generateSolarSystem();
    }
    
    private generateSolarSystem(): void {
        // Central star
        this.celestialBodies.push({
            position: { x: 0, y: 0 },
            radius: 50,
            mass: 1000,
            type: 'star',
            name: 'Sol',
            color: COLORS.YELLOW_LIGHT,
            rotation: 0,
            rotationSpeed: 0.005
        });
        
        // Planets
        const planetData = [
            { name: 'Mercury', distance: 150, radius: 8, color: COLORS.BROWN_RUST, mass: 10 },
            { name: 'Venus', distance: 200, radius: 10, color: COLORS.ORANGE_MED, mass: 15 },
            { name: 'Earth', distance: 250, radius: 12, color: COLORS.CYAN, mass: 20 },
            { name: 'Mars', distance: 320, radius: 9, color: COLORS.RED_MED, mass: 12 }
        ];
        
        planetData.forEach((planetDef, i) => {
            const angle = (Math.PI * 2 / planetData.length) * i;
            this.celestialBodies.push({
                position: {
                    x: Math.cos(angle) * planetDef.distance,
                    y: Math.sin(angle) * planetDef.distance
                },
                radius: planetDef.radius,
                mass: planetDef.mass,
                type: 'planet',
                name: planetDef.name,
                color: planetDef.color,
                orbitDistance: planetDef.distance,
                orbitSpeed: 0.01 / planetDef.distance,
                orbitAngle: angle,
                rotation: 0,
                rotationSpeed: 0.02
            });
        });
        
        // Asteroids
        for (let i = 0; i < 20; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = 380 + Math.random() * 80;
            this.celestialBodies.push({
                position: {
                    x: Math.cos(angle) * distance,
                    y: Math.sin(angle) * distance
                },
                radius: 2 + Math.random() * 4,
                mass: 1,
                type: 'asteroid',
                color: COLORS.HULL_SECONDARY,
                rotation: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.02
            });
        }
    }
    
    public update(deltaTime: number): void {
        this.celestialBodies.forEach(body => {
            if (body.type === 'planet') {
                body.orbitAngle += body.orbitSpeed * deltaTime;
                body.position.x = Math.cos(body.orbitAngle) * body.orbitDistance;
                body.position.y = Math.sin(body.orbitAngle) * body.orbitDistance;
            }
            body.rotation += body.rotationSpeed * deltaTime;
        });
    }
    
    public render(ctx: CanvasRenderingContext2D, camera: Camera): void {
        // Render star field
        this.renderStarField(ctx, camera);
        
        // Render celestial bodies
        this.celestialBodies.forEach(body => {
            this.renderCelestialBody(ctx, camera, body);
        });
    }
    
    private renderStarField(ctx: CanvasRenderingContext2D, camera: Camera): void {
        // Simple star field
        ctx.fillStyle = COLORS.HULL_SECONDARY;
        for (let i = 0; i < 100; i++) {
            const starX = (i * 123.456) % 2000 - 1000;
            const starY = (i * 789.123) % 1500 - 750;
            
            const screenPos = camera.worldToScreen(starX * 0.1, starY * 0.1);
            
            if (screenPos.x >= 0 && screenPos.x <= this.game.getCanvas().width &&
                screenPos.y >= 0 && screenPos.y <= this.game.getCanvas().height) {
                ctx.fillRect(screenPos.x, screenPos.y, 1, 1);
            }
        }
    }
    
    private renderCelestialBody(ctx: CanvasRenderingContext2D, camera: Camera, body: any): void {
        const screenPos = camera.worldToScreen(body.position.x, body.position.y);
        
        // Skip if off-screen
        if (screenPos.x < -body.radius || screenPos.x > this.game.getCanvas().width + body.radius ||
            screenPos.y < -body.radius || screenPos.y > this.game.getCanvas().height + body.radius) {
            return;
        }
        
        ctx.save();
        ctx.translate(screenPos.x, screenPos.y);
        ctx.rotate(body.rotation);
        
        // Render based on type
        if (body.type === 'star') {
            // Star glow
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, body.radius + 20);
            gradient.addColorStop(0, body.color);
            gradient.addColorStop(0.6, body.color + '88');
            gradient.addColorStop(1, 'transparent');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(-body.radius - 20, -body.radius - 20, (body.radius + 20) * 2, (body.radius + 20) * 2);
        }
        
        // Main body
        ctx.fillStyle = body.color;
        ctx.beginPath();
        ctx.arc(0, 0, body.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Add some surface detail for planets
        if (body.type === 'planet') {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            for (let i = 0; i < 3; i++) {
                const detailAngle = (i / 3) * Math.PI * 2;
                const x = Math.cos(detailAngle) * body.radius * 0.4;
                const y = Math.sin(detailAngle) * body.radius * 0.4;
                ctx.beginPath();
                ctx.arc(x, y, body.radius * 0.2, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        ctx.restore();
        
        // Label for larger bodies
        if (body.type !== 'asteroid' && camera.zoom > 0.5) {
            ctx.fillStyle = COLORS.HULL_PRIMARY;
            ctx.font = '8px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(body.name, screenPos.x, screenPos.y + body.radius + 20);
        }
    }
}

// Interstellar Space Scene
class InterstellarSpaceScene {
    private starSystems: any[] = [];
    
    constructor(private game: Game) {
        this.generateStarSystems();
    }
    
    private generateStarSystems(): void {
        for (let i = 0; i < 20; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = 200 + Math.random() * 800;
            
            this.starSystems.push({
                position: {
                    x: Math.cos(angle) * distance,
                    y: Math.sin(angle) * distance
                },
                name: `System-${i + 1}`,
                type: ['G-Class', 'K-Class', 'M-Class'][Math.floor(Math.random() * 3)],
                color: [COLORS.YELLOW_LIGHT, COLORS.ORANGE_LIGHT, COLORS.RED_MED][Math.floor(Math.random() * 3)],
                size: 5 + Math.random() * 10,
                explored: i === 0
            });
        }
    }
    
    public update(deltaTime: number): void {
        // Slow galaxy rotation
        this.starSystems.forEach(system => {
            const distance = Math.sqrt(system.position.x ** 2 + system.position.y ** 2);
            if (distance > 100) {
                const rotationSpeed = 0.0001 / distance;
                const currentAngle = Math.atan2(system.position.y, system.position.x);
                const newAngle = currentAngle + rotationSpeed * deltaTime;
                system.position.x = Math.cos(newAngle) * distance;
                system.position.y = Math.sin(newAngle) * distance;
            }
        });
    }
    
    public render(ctx: CanvasRenderingContext2D, camera: Camera): void {
        // Galaxy background
        const gradient = ctx.createLinearGradient(0, 0, this.game.getCanvas().width, 0);
        gradient.addColorStop(0, 'rgba(106, 175, 157, 0.1)');
        gradient.addColorStop(0.5, 'rgba(106, 175, 157, 0.2)');
        gradient.addColorStop(1, 'rgba(106, 175, 157, 0.1)');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, this.game.getCanvas().height * 0.3, this.game.getCanvas().width, this.game.getCanvas().height * 0.4);
        
        // Render star systems
        this.starSystems.forEach(system => {
            const screenPos = camera.worldToScreen(system.position.x, system.position.y);
            
            // System glow
            const gradient = ctx.createRadialGradient(screenPos.x, screenPos.y, 0, screenPos.x, screenPos.y, system.size + 10);
            gradient.addColorStop(0, system.color);
            gradient.addColorStop(0.7, system.color + '44');
            gradient.addColorStop(1, 'transparent');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(screenPos.x - system.size - 10, screenPos.y - system.size - 10, (system.size + 10) * 2, (system.size + 10) * 2);
            
            // System star
            ctx.fillStyle = system.color;
            ctx.beginPath();
            ctx.arc(screenPos.x, screenPos.y, system.size, 0, Math.PI * 2);
            ctx.fill();
            
            // Exploration indicator
            if (system.explored) {
                ctx.strokeStyle = COLORS.FX_GLOW_PRIMARY;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, system.size + 8, 0, Math.PI * 2);
                ctx.stroke();
            }
        });
    }
}

// Particle System
export class ParticleSystem {
    private particles: any[] = [];
    private beams: any[] = [];
    
    constructor(private game: Game) {}
    
    public createLaserBeam(position: { x: number; y: number }, angle: number): void {
        this.beams.push({
            startX: position.x + Math.cos(angle) * 15,
            startY: position.y + Math.sin(angle) * 15,
            endX: position.x + Math.cos(angle) * 500,
            endY: position.y + Math.sin(angle) * 500,
            life: 0.1,
            maxLife: 0.1,
            color: COLORS.FX_GLOW_PRIMARY
        });
    }
    
    public createEngineParticles(position: { x: number; y: number }, angle: number, intensity: number): void {
        for (let i = 0; i < Math.floor(intensity * 5); i++) {
            this.particles.push({
                x: position.x - Math.cos(angle) * 12,
                y: position.y - Math.sin(angle) * 12,
                vx: -Math.cos(angle) * 100 + (Math.random() - 0.5) * 50,
                vy: -Math.sin(angle) * 100 + (Math.random() - 0.5) * 50,
                life: 0.5 + Math.random() * 0.5,
                maxLife: 1.0,
                color: COLORS.FX_GLOW_SECONDARY,
                type: 'engine'
            });
        }
    }
    
    public update(deltaTime: number): void {
        // Update particles
        this.particles = this.particles.filter(particle => {
            particle.x += particle.vx * deltaTime;
            particle.y += particle.vy * deltaTime;
            particle.life -= deltaTime;
            return particle.life > 0;
        });
        
        // Update beams
        this.beams = this.beams.filter(beam => {
            beam.life -= deltaTime;
            return beam.life > 0;
        });
    }
    
    public render(ctx: CanvasRenderingContext2D, camera: Camera): void {
        // Render beams
        this.beams.forEach(beam => {
            const alpha = beam.life / beam.maxLife;
            ctx.globalAlpha = alpha;
            ctx.strokeStyle = beam.color;
            ctx.lineWidth = 2;
            
            const startPos = camera.worldToScreen(beam.startX, beam.startY);
            const endPos = camera.worldToScreen(beam.endX, beam.endY);
            
            ctx.beginPath();
            ctx.moveTo(startPos.x, startPos.y);
            ctx.lineTo(endPos.x, endPos.y);
            ctx.stroke();
        });
        
        // Render particles
        this.particles.forEach(particle => {
            const alpha = particle.life / particle.maxLife;
            ctx.globalAlpha = alpha;
            ctx.fillStyle = particle.color;
            
            const screenPos = camera.worldToScreen(particle.x, particle.y);
            ctx.fillRect(screenPos.x - 1, screenPos.y - 1, 2, 2);
        });
        
        ctx.globalAlpha = 1.0;
    }
    
    public getParticleCount(): number {
        return this.particles.length + this.beams.length;
    }
    
    public destroy(): void {
        this.particles = [];
        this.beams = [];
    }
}

// Physics Engine
export class PhysicsEngine {
    constructor(private game: Game) {}
    
    public update(deltaTime: number): void {
        // Apply physics to player
        const player = this.game.player;
        if (player) {
            this.applyNewtonian(player, deltaTime);
        }
    }
    
    private applyNewtonian(ship: any, deltaTime: number): void {
        // Apply velocity to position
        ship.position.x += ship.velocity.x * deltaTime;
        ship.position.y += ship.velocity.y * deltaTime;
        
        // Apply minimal space friction
        const friction = 0.999;
        ship.velocity.x *= Math.pow(friction, deltaTime);
        ship.velocity.y *= Math.pow(friction, deltaTime);
    }
}

// UI Manager (simplified)
export class UIManager {
    private updateInterval: number | null = null;
    
    constructor(private game: Game) {}
    
    public initialize(): void {
        this.setupUIEventListeners();
        this.startUIUpdates();
    }
    
    private setupUIEventListeners(): void {
        // Status bar button handlers
        document.getElementById('shieldBtn')?.addEventListener('click', () => {
            const player = this.game.player;
            player.systems.shields = !player.systems.shields;
            this.toggleButton('shieldBtn', player.systems.shields);
        });
        
        document.getElementById('inventoryBtn')?.addEventListener('click', () => {
            this.game.stateManager.setState('inventory');
        });
        
        document.getElementById('galaxyMapBtn')?.addEventListener('click', () => {
            this.game.sceneManager.switchScene('interstellarSpace');
        });
        
        document.getElementById('systemMapBtn')?.addEventListener('click', () => {
            this.game.sceneManager.switchScene('starSystem');
        });
        
        // Close inventory button
        document.getElementById('closeInventoryBtn')?.addEventListener('click', () => {
            this.game.stateManager.setState('playing');
        });
    }
    
    private startUIUpdates(): void {
        this.updateInterval = window.setInterval(() => {
            if (this.game.stateManager.getCurrentState() === 'playing') {
                this.updateStatusBar();
            }
        }, 100);
    }
    
    private updateStatusBar(): void {
        const player = this.game.player;
        if (!player) return;
        
        // Update system bars
        this.updateBar('hullBar', 'hullValue', player.systems.hull);
        this.updateBar('shieldBar', 'shieldValue', player.systems.shield);
        this.updateBar('fuelBar', 'fuelValue', player.systems.fuel);
        this.updateBar('energyBar', 'energyValue', player.systems.energy);
        this.updateBar('thrustBar', 'thrustValue', player.thrust * 100);
        
        // Update weapon display
        const weaponName = document.getElementById('weaponName');
        const weaponPower = document.getElementById('weaponPower');
        const weaponHeat = document.getElementById('weaponHeat');
        
        if (weaponName) weaponName.textContent = 'LASER CANNON MK-II';
        if (weaponPower) weaponPower.textContent = '85%';
        if (weaponHeat) weaponHeat.textContent = Math.round(player.weapons?.laser?.heat || 0) + '%';
    }
    
    private updateBar(barId: string, valueId: string, value: number): void {
        const bar = document.getElementById(barId) as HTMLElement;
        const valueEl = document.getElementById(valueId) as HTMLElement;
        
        if (bar) {
            bar.style.width = Math.max(0, Math.min(100, value)) + '%';
        }
        
        if (valueEl) {
            valueEl.textContent = Math.round(value) + '%';
        }
    }
    
    private toggleButton(buttonId: string, active: boolean): void {
        const button = document.getElementById(buttonId);
        if (button) {
            button.classList.toggle('active', active);
        }
    }
    
    public update(deltaTime: number): void {
        // UI update logic
    }
    
    public destroy(): void {
        if (this.updateInterval) {
            clearInterval(this.updateInterval);
            this.updateInterval = null;
        }
    }
}

// Simple Galaxy class
export class Galaxy {
    public starSystems: any[] = [];
    
    constructor(private config: any) {}
    
    public async generate(): Promise<void> {
        // Generate star systems based on config
        const systemCount = this.config.galaxy.systemCount;
        
        for (let i = 0; i < systemCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = 100 + Math.random() * 500;
            
            this.starSystems.push({
                id: i,
                name: `System-${i + 1}`,
                position: {
                    x: Math.cos(angle) * distance,
                    y: Math.sin(angle) * distance
                },
                type: 'G-Class',
                color: COLORS.YELLOW_LIGHT,
                size: 5 + Math.random() * 5,
                explored: false
            });
        }
        
        console.log(`🌌 Generated ${systemCount} star systems`);
    }
}

// Audio Manager
export class AudioManager {
    private static instance: AudioManager;
    private currentMusic: HTMLAudioElement | null = null;
    private soundEffects: Map<string, HTMLAudioElement> = new Map();
    private musicEnabled: boolean = true;
    private sfxEnabled: boolean = true;
    
    public static getInstance(): AudioManager {
        if (!AudioManager.instance) {
            AudioManager.instance = new AudioManager();
        }
        return AudioManager.instance;
    }
    
    public initialize(): void {
        console.log('🔊 Audio Manager initialized');
        // In a real implementation, we'd load audio files here
    }
    
    public playMusic(track: string): void {
        if (!this.musicEnabled) return;
        console.log(`🎵 Playing music: ${track}`);
        // Implementation would play actual audio
    }
    
    public stopMusic(): void {
        console.log('🔇 Stopping music');
        // Implementation would stop actual audio
    }
    
    public pauseMusic(): void {
        console.log('⏸️ Pausing music');
    }
    
    public resumeMusic(): void {
        console.log('▶️ Resuming music');
    }
    
    public playSFX(effect: string): void {
        if (!this.sfxEnabled) return;
        console.log(`🔊 Playing SFX: ${effect}`);
    }
}

// Asset Manager
export class AssetManager {
    private static instance: AssetManager;
    private loaded: boolean = false;
    
    public static getInstance(): AssetManager {
        if (!AssetManager.instance) {
            AssetManager.instance = new AssetManager();
        }
        return AssetManager.instance;
    }
    
    public initialize(): void {
        this.loaded = true;
        console.log('📦 Asset Manager initialized');
    }
    
    public isLoaded(): boolean {
        return this.loaded;
    }
}

// Save Manager
export class SaveManager {
    private static instance: SaveManager;
    
    public static getInstance(): SaveManager {
        if (!SaveManager.instance) {
            SaveManager.instance = new SaveManager();
        }
        return SaveManager.instance;
    }
    
    public initialize(): void {
        console.log('💾 Save Manager initialized');
    }
    
    public saveGame(data: any): void {
        try {
            localStorage.setItem('spaceExplorer_save', JSON.stringify(data));
            console.log('💾 Game saved');
        } catch (error) {
            console.error('❌ Failed to save game:', error);
        }
    }
    
    public loadGame(): any {
        try {
            const data = localStorage.getItem('spaceExplorer_save');
            return data ? JSON.parse(data) : null;
        } catch (error) {
            console.error('❌ Failed to load game:', error);
            return null;
        }
    }
}