// Inventory System - Comprehensive item and cargo management
export interface InventoryItem {
    id: string;
    name: string;
    category: ItemCategory;
    quantity: number;
    mass: number;
    volume: number;
    value: number;
    rarity: ItemRarity;
    description: string;
    properties: Map<string, any>;
    stackable: boolean;
    maxStack: number;
}

export enum ItemCategory {
    ELEMENTS = 'elements',
    RESOURCES = 'resources',
    COMPONENTS = 'components',
    FUEL = 'fuel',
    RATIONS = 'rations',
    WEAPONS = 'weapons',
    SHIELDS = 'shields',
    ENGINES = 'engines',
    ALIEN_ARTIFACTS = 'alien_artifacts',
    BIOLOGICAL = 'biological',
    ELECTRONICS = 'electronics',
    BUILDING_MATERIALS = 'building_materials',
    TRADE_GOODS = 'trade_goods',
    BLUEPRINTS = 'blueprints',
    DATA = 'data'
}

export enum ItemRarity {
    COMMON = 'common',
    UNCOMMON = 'uncommon',
    RARE = 'rare',
    EPIC = 'epic',
    LEGENDARY = 'legendary',
    ALIEN = 'alien'
}

export interface CargoHold {
    id: string;
    name: string;
    maxMass: number;
    maxVolume: number;
    currentMass: number;
    currentVolume: number;
    items: Map<string, InventoryItem>;
    restrictions: ItemCategory[];
    temperature: number;
    atmosphere: string;
    shielding: number;
}

export class InventorySystem {
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D;
    private cargoHolds: Map<string, CargoHold>;
    private selectedHold: string;
    private selectedItem: string | null;
    private filter: ItemCategory | 'all';
    private sortBy: 'name' | 'value' | 'mass' | 'quantity';
    private scrollOffset: number;
    private itemsPerPage: number;
    private isVisible: boolean;

    // Color palette
    private colors = {
        background: '#201127',
        panel: '#1b1e34',
        text: '#E2DFD0',
        textSecondary: '#A27B5C',
        accent: '#F97300',
        success: '#6aaf9d',
        warning: '#ec9a6d',
        danger: '#d9626b',
        rare: '#c24b6e',
        epic: '#a73169',
        legendary: '#7077A1'
    };

    // Periodic table elements as base resources
    private elements = new Map<string, any>([
        ['H', { name: 'Hydrogen', symbol: 'H', atomicNumber: 1, category: 'nonmetal', uses: ['fuel', 'coolant'] }],
        ['He', { name: 'Helium', symbol: 'He', atomicNumber: 2, category: 'noble_gas', uses: ['coolant', 'shielding'] }],
        ['Li', { name: 'Lithium', symbol: 'Li', atomicNumber: 3, category: 'alkali_metal', uses: ['batteries', 'alloys'] }],
        ['Be', { name: 'Beryllium', symbol: 'Be', atomicNumber: 4, category: 'alkaline_earth', uses: ['aerospace', 'neutron_moderation'] }],
        ['C', { name: 'Carbon', symbol: 'C', atomicNumber: 6, category: 'nonmetal', uses: ['construction', 'filtration'] }],
        ['N', { name: 'Nitrogen', symbol: 'N', atomicNumber: 7, category: 'nonmetal', uses: ['life_support', 'propellant'] }],
        ['O', { name: 'Oxygen', symbol: 'O', atomicNumber: 8, category: 'nonmetal', uses: ['life_support', 'oxidizer'] }],
        ['Fe', { name: 'Iron', symbol: 'Fe', atomicNumber: 26, category: 'transition_metal', uses: ['construction', 'magnetics'] }],
        ['Cu', { name: 'Copper', symbol: 'Cu', atomicNumber: 29, category: 'transition_metal', uses: ['electronics', 'heat_exchange'] }],
        ['Au', { name: 'Gold', symbol: 'Au', atomicNumber: 79, category: 'transition_metal', uses: ['electronics', 'currency'] }],
        ['Pt', { name: 'Platinum', symbol: 'Pt', atomicNumber: 78, category: 'transition_metal', uses: ['catalysts', 'electronics'] }],
        ['U', { name: 'Uranium', symbol: 'U', atomicNumber: 92, category: 'actinoid', uses: ['reactor_fuel', 'weapons'] }]
    ]);

    constructor(canvas: HTMLCanvasElement) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d')!;
        this.ctx.imageSmoothingEnabled = false;
        this.cargoHolds = new Map();
        this.selectedHold = 'main_cargo';
        this.selectedItem = null;
        this.filter = 'all';
        this.sortBy = 'name';
        this.scrollOffset = 0;
        this.itemsPerPage = 10;
        this.isVisible = false;

        this.initializeCargoHolds();
        this.generateStartingItems();
        this.setupEventListeners();
    }

    private initializeCargoHolds(): void {
        // Main cargo hold
        this.cargoHolds.set('main_cargo', {
            id: 'main_cargo',
            name: 'MAIN CARGO HOLD',
            maxMass: 1000,
            maxVolume: 500,
            currentMass: 0,
            currentVolume: 0,
            items: new Map(),
            restrictions: [],
            temperature: 273,
            atmosphere: 'vacuum',
            shielding: 1.0
        });

        // Specialized storage
        this.cargoHolds.set('fuel_tank', {
            id: 'fuel_tank',
            name: 'FUEL STORAGE',
            maxMass: 500,
            maxVolume: 200,
            currentMass: 0,
            currentVolume: 0,
            items: new Map(),
            restrictions: [ItemCategory.FUEL],
            temperature: 77,
            atmosphere: 'inert',
            shielding: 2.0
        });

        this.cargoHolds.set('bio_storage', {
            id: 'bio_storage',
            name: 'BIOLOGICAL STORAGE',
            maxMass: 200,
            maxVolume: 100,
            currentMass: 0,
            currentVolume: 0,
            items: new Map(),
            restrictions: [ItemCategory.BIOLOGICAL, ItemCategory.RATIONS],
            temperature: 253,
            atmosphere: 'nitrogen',
            shielding: 1.5
        });

        this.cargoHolds.set('secure_vault', {
            id: 'secure_vault',
            name: 'SECURE VAULT',
            maxMass: 100,
            maxVolume: 50,
            currentMass: 0,
            currentVolume: 0,
            items: new Map(),
            restrictions: [ItemCategory.ALIEN_ARTIFACTS, ItemCategory.BLUEPRINTS, ItemCategory.DATA],
            temperature: 273,
            atmosphere: 'vacuum',
            shielding: 3.0
        });
    }

    private generateStartingItems(): void {
        const startingItems = [
            // Basic elements
            this.createItem('iron_ore', 'Iron Ore', ItemCategory.ELEMENTS, 50, 2.0, 1.0, 10, ItemRarity.COMMON, 
                'Common metallic ore used in construction and manufacturing'),
            this.createItem('hydrogen_fuel', 'Hydrogen Fuel', ItemCategory.FUEL, 100, 0.1, 5.0, 5, ItemRarity.COMMON, 
                'Primary propulsion fuel for most spacecraft engines'),
            this.createItem('rations', 'Emergency Rations', ItemCategory.RATIONS, 20, 0.5, 0.2, 8, ItemRarity.COMMON, 
                'Preserved food supplies for long-duration missions'),
            this.createItem('copper_wire', 'Copper Wiring', ItemCategory.ELECTRONICS, 10, 1.5, 0.3, 25, ItemRarity.UNCOMMON, 
                'High-conductivity wiring for electronic systems'),
            this.createItem('water', 'Purified Water', ItemCategory.RESOURCES, 30, 1.0, 1.0, 12, ItemRarity.COMMON, 
                'Essential for life support and cooling systems')
        ];

        const mainCargo = this.cargoHolds.get('main_cargo')!;
        startingItems.forEach(item => {
            this.addItemToHold('main_cargo', item);
        });
    }

    private createItem(id: string, name: string, category: ItemCategory, quantity: number, 
                      mass: number, volume: number, value: number, rarity: ItemRarity, 
                      description: string): InventoryItem {
        return {
            id,
            name,
            category,
            quantity,
            mass,
            volume,
            value,
            rarity,
            description,
            properties: new Map(),
            stackable: true,
            maxStack: 100
        };
    }

    private setupEventListeners(): void {
        this.canvas.addEventListener('click', (e) => {
            if (!this.isVisible) return;
            
            const rect = this.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            this.handleClick(x, y);
        });

        this.canvas.addEventListener('wheel', (e) => {
            if (!this.isVisible) return;
            
            e.preventDefault();
            const scrollDirection = e.deltaY > 0 ? 1 : -1;
            this.scrollOffset = Math.max(0, this.scrollOffset + scrollDirection);
        });

        document.addEventListener('keydown', (e) => {
            if (!this.isVisible) return;
            
            switch (e.key) {
                case 'Escape':
                    this.hide();
                    break;
                case 'Tab':
                    e.preventDefault();
                    this.switchToNextHold();
                    break;
                case '1':
                case '2':
                case '3':
                case '4':
                    const holdIndex = parseInt(e.key) - 1;
                    const holdIds = Array.from(this.cargoHolds.keys());
                    if (holdIds[holdIndex]) {
                        this.selectedHold = holdIds[holdIndex];
                    }
                    break;
            }
        });
    }

    private handleClick(x: number, y: number): void {
        // Check cargo hold tabs
        if (y >= 60 && y <= 90) {
            const holdIds = Array.from(this.cargoHolds.keys());
            const tabWidth = this.canvas.width / holdIds.length;
            const selectedIndex = Math.floor(x / tabWidth);
            if (selectedIndex >= 0 && selectedIndex < holdIds.length) {
                this.selectedHold = holdIds[selectedIndex];
                this.scrollOffset = 0;
                return;
            }
        }

        // Check filter buttons
        if (y >= 100 && y <= 120) {
            const filters = ['all', ...Object.values(ItemCategory)];
            const buttonWidth = 80;
            const filterIndex = Math.floor(x / buttonWidth);
            if (filterIndex >= 0 && filterIndex < filters.length) {
                this.filter = filters[filterIndex] as ItemCategory | 'all';
                this.scrollOffset = 0;
                return;
            }
        }

        // Check sort buttons
        if (y >= 130 && y <= 150) {
            const sortOptions = ['name', 'value', 'mass', 'quantity'];
            const buttonWidth = 100;
            const sortIndex = Math.floor(x / buttonWidth);
            if (sortIndex >= 0 && sortIndex < sortOptions.length) {
                this.sortBy = sortOptions[sortIndex] as 'name' | 'value' | 'mass' | 'quantity';
                return;
            }
        }

        // Check item selection
        const itemListY = 180;
        if (y >= itemListY && y <= itemListY + this.itemsPerPage * 40) {
            const itemIndex = Math.floor((y - itemListY) / 40) + this.scrollOffset;
            const filteredItems = this.getFilteredAndSortedItems();
            if (itemIndex >= 0 && itemIndex < filteredItems.length) {
                this.selectedItem = filteredItems[itemIndex].id;
                return;
            }
        }

        // Check action buttons
        if (this.selectedItem) {
            // Transfer button
            if (x >= this.canvas.width - 200 && x <= this.canvas.width - 20 && 
                y >= this.canvas.height - 120 && y <= this.canvas.height - 90) {
                this.transferSelectedItem();
            }
            
            // Jettison button
            if (x >= this.canvas.width - 200 && x <= this.canvas.width - 20 && 
                y >= this.canvas.height - 80 && y <= this.canvas.height - 50) {
                this.jettisonSelectedItem();
            }
        }
    }

    public show(): void {
        this.isVisible = true;
    }

    public hide(): void {
        this.isVisible = false;
        this.selectedItem = null;
    }

    public toggle(): void {
        if (this.isVisible) {
            this.hide();
        } else {
            this.show();
        }
    }

    public render(): void {
        if (!this.isVisible) return;

        // Background
        this.ctx.fillStyle = 'rgba(32, 17, 39, 0.95)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Title bar
        this.renderTitleBar();

        // Cargo hold tabs
        this.renderCargoHoldTabs();

        // Filter and sort controls
        this.renderFilterControls();
        this.renderSortControls();

        // Current cargo hold info
        this.renderCargoHoldInfo();

        // Item list
        this.renderItemList();

        // Selected item details
        if (this.selectedItem) {
            this.renderItemDetails();
        }

        // Action buttons
        this.renderActionButtons();

        // Scan lines effect
        this.renderScanLines();
    }

    private renderTitleBar(): void {
        this.ctx.fillStyle = this.colors.accent;
        this.ctx.font = 'bold 20px monospace';
        this.ctx.textAlign = 'center';
        this.ctx.fillText('CARGO MANIFEST', this.canvas.width / 2, 35);

        // Close button
        this.ctx.fillStyle = this.colors.danger;
        this.ctx.font = 'bold 16px monospace';
        this.ctx.textAlign = 'right';
        this.ctx.fillText('[X]', this.canvas.width - 20, 35);
    }

    private renderCargoHoldTabs(): void {
        const holdIds = Array.from(this.cargoHolds.keys());
        const tabWidth = this.canvas.width / holdIds.length;

        holdIds.forEach((holdId, index) => {
            const x = index * tabWidth;
            const isSelected = holdId === this.selectedHold;
            const hold = this.cargoHolds.get(holdId)!;

            // Tab background
            this.ctx.fillStyle = isSelected ? this.colors.accent : this.colors.panel;
            this.ctx.fillRect(x, 60, tabWidth, 30);

            // Tab border
            this.ctx.strokeStyle = this.colors.text;
            this.ctx.lineWidth = 1;
            this.ctx.strokeRect(x, 60, tabWidth, 30);

            // Tab text
            this.ctx.fillStyle = isSelected ? this.colors.background : this.colors.text;
            this.ctx.font = 'bold 10px monospace';
            this.ctx.textAlign = 'center';
            this.ctx.fillText(hold.name, x + tabWidth / 2, 80);

            // Capacity indicator
            const fillPercentage = hold.currentMass / hold.maxMass;
            const barWidth = tabWidth - 20;
            const barX = x + 10;
            const barY = 85;

            this.ctx.fillStyle = this.colors.background;
            this.ctx.fillRect(barX, barY, barWidth, 4);

            let barColor = this.colors.success;
            if (fillPercentage > 0.8) barColor = this.colors.warning;
            if (fillPercentage > 0.95) barColor = this.colors.danger;

            this.ctx.fillStyle = barColor;
            this.ctx.fillRect(barX, barY, barWidth * fillPercentage, 4);
        });
    }

    private renderFilterControls(): void {
        this.ctx.fillStyle = this.colors.text;
        this.ctx.font = 'bold 10px monospace';
        this.ctx.textAlign = 'left';
        this.ctx.fillText('FILTER:', 10, 115);

        const filters = ['ALL', 'ELEM', 'FUEL', 'RATIONS', 'ELEC', 'ALIEN'];
        filters.forEach((filter, index) => {
            const x = 60 + index * 80;
            const isSelected = (filter === 'ALL' && this.filter === 'all') ||
                              (filter !== 'ALL' && this.filter.toUpperCase().includes(filter));

            this.ctx.fillStyle = isSelected ? this.colors.accent : this.colors.panel;
            this.ctx.fillRect(x, 100, 75, 20);

            this.ctx.strokeStyle = this.colors.text;
            this.ctx.strokeRect(x, 100, 75, 20);

            this.ctx.fillStyle = isSelected ? this.colors.background : this.colors.text;
            this.ctx.textAlign = 'center';
            this.ctx.fillText(filter, x + 37, 115);
        });
    }

    private renderSortControls(): void {
        this.ctx.fillStyle = this.colors.text;
        this.ctx.font = 'bold 10px monospace';
        this.ctx.textAlign = 'left';
        this.ctx.fillText('SORT BY:', 10, 145);

        const sortOptions = ['NAME', 'VALUE', 'MASS', 'QTY'];
        sortOptions.forEach((option, index) => {
            const x = 80 + index * 100;
            const isSelected = option.toLowerCase().includes(this.sortBy);

            this.ctx.fillStyle = isSelected ? this.colors.accent : this.colors.panel;
            this.ctx.fillRect(x, 130, 95, 20);

            this.ctx.strokeStyle = this.colors.text;
            this.ctx.strokeRect(x, 130, 95, 20);

            this.ctx.fillStyle = isSelected ? this.colors.background : this.colors.text;
            this.ctx.textAlign = 'center';
            this.ctx.fillText(option, x + 47, 145);
        });
    }

    private renderCargoHoldInfo(): void {
        const hold = this.cargoHolds.get(this.selectedHold)!;
        const infoY = 165;

        this.ctx.fillStyle = this.colors.text;
        this.ctx.font = '10px monospace';
        this.ctx.textAlign = 'left';

        const massPercent = ((hold.currentMass / hold.maxMass) * 100).toFixed(1);
        const volumePercent = ((hold.currentVolume / hold.maxVolume) * 100).toFixed(1);

        this.ctx.fillText(`MASS: ${hold.currentMass.toFixed(1)}/${hold.maxMass} kg (${massPercent}%)`, 10, infoY);
        this.ctx.fillText(`VOLUME: ${hold.currentVolume.toFixed(1)}/${hold.maxVolume} m³ (${volumePercent}%)`, 250, infoY);
        this.ctx.fillText(`TEMP: ${hold.temperature}K`, 500, infoY);
        this.ctx.fillText(`ATMO: ${hold.atmosphere.toUpperCase()}`, 650, infoY);
    }

    private renderItemList(): void {
        const itemListY = 180;
        const itemHeight = 40;
        const filteredItems = this.getFilteredAndSortedItems();

        // List header
        this.ctx.fillStyle = this.colors.panel;
        this.ctx.fillRect(10, itemListY - 20, this.canvas.width - 220, 20);

        this.ctx.fillStyle = this.colors.text;
        this.ctx.font = 'bold 8px monospace';
        this.ctx.textAlign = 'left';
        this.ctx.fillText('NAME', 20, itemListY - 8);
        this.ctx.fillText('QTY', 200, itemListY - 8);
        this.ctx.fillText('MASS', 250, itemListY - 8);
        this.ctx.fillText('VALUE', 320, itemListY - 8);
        this.ctx.fillText('RARITY', 380, itemListY - 8);

        // Items
        const startIndex = this.scrollOffset;
        const endIndex = Math.min(startIndex + this.itemsPerPage, filteredItems.length);

        for (let i = startIndex; i < endIndex; i++) {
            const item = filteredItems[i];
            const y = itemListY + (i - startIndex) * itemHeight;
            const isSelected = item.id === this.selectedItem;

            // Item background
            if (isSelected) {
                this.ctx.fillStyle = 'rgba(249, 115, 0, 0.3)';
                this.ctx.fillRect(10, y, this.canvas.width - 220, itemHeight);
            }

            // Alternating row colors
            if (i % 2 === 0) {
                this.ctx.fillStyle = 'rgba(27, 30, 52, 0.5)';
                this.ctx.fillRect(10, y, this.canvas.width - 220, itemHeight);
            }

            // Item details
            this.ctx.fillStyle = this.getRarityColor(item.rarity);
            this.ctx.font = 'bold 10px monospace';
            this.ctx.textAlign = 'left';
            this.ctx.fillText(item.name, 20, y + 15);

            this.ctx.fillStyle = this.colors.text;
            this.ctx.font = '10px monospace';
            this.ctx.fillText(item.quantity.toString(), 200, y + 15);
            this.ctx.fillText(`${(item.mass * item.quantity).toFixed(1)}kg`, 250, y + 15);
            this.ctx.fillText(`${(item.value * item.quantity).toFixed(0)}¢`, 320, y + 15);
            this.ctx.fillText(item.rarity.toUpperCase(), 380, y + 15);

            // Item description
            this.ctx.fillStyle = this.colors.textSecondary;
            this.ctx.font = '8px monospace';
            const truncatedDesc = item.description.length > 50 ? 
                item.description.substring(0, 47) + '...' : item.description;
            this.ctx.fillText(truncatedDesc, 20, y + 30);
        }

        // Scroll indicator
        if (filteredItems.length > this.itemsPerPage) {
            const scrollPercent = this.scrollOffset / (filteredItems.length - this.itemsPerPage);
            const scrollBarHeight = 200;
            const scrollBarY = itemListY;
            const scrollBarX = this.canvas.width - 210;

            this.ctx.fillStyle = this.colors.panel;
            this.ctx.fillRect(scrollBarX, scrollBarY, 10, scrollBarHeight);

            this.ctx.fillStyle = this.colors.accent;
            const thumbY = scrollBarY + scrollPercent * (scrollBarHeight - 20);
            this.ctx.fillRect(scrollBarX, thumbY, 10, 20);
        }
    }

    private renderItemDetails(): void {
        const item = this.getItemById(this.selectedItem!);
        if (!item) return;

        const detailsX = this.canvas.width - 200;
        const detailsY = 180;
        const detailsWidth = 180;
        const detailsHeight = 300;

        // Background
        this.ctx.fillStyle = this.colors.panel;
        this.ctx.fillRect(detailsX, detailsY, detailsWidth, detailsHeight);

        this.ctx.strokeStyle = this.getRarityColor(item.rarity);
        this.ctx.lineWidth = 2;
        this.ctx.strokeRect(detailsX, detailsY, detailsWidth, detailsHeight);

        // Item name
        this.ctx.fillStyle = this.getRarityColor(item.rarity);
        this.ctx.font = 'bold 12px monospace';
        this.ctx.textAlign = 'center';
        this.ctx.fillText(item.name, detailsX + detailsWidth / 2, detailsY + 20);

        // Properties
        this.ctx.fillStyle = this.colors.text;
        this.ctx.font = '10px monospace';
        this.ctx.textAlign = 'left';

        const properties = [
            `Category: ${item.category.toUpperCase()}`,
            `Quantity: ${item.quantity}`,
            `Unit Mass: ${item.mass.toFixed(2)} kg`,
            `Unit Volume: ${item.volume.toFixed(2)} m³`,
            `Unit Value: ${item.value.toFixed(0)} credits`,
            `Total Mass: ${(item.mass * item.quantity).toFixed(2)} kg`,
            `Total Value: ${(item.value * item.quantity).toFixed(0)} credits`,
            `Rarity: ${item.rarity.toUpperCase()}`
        ];

        properties.forEach((prop, index) => {
            this.ctx.fillText(prop, detailsX + 10, detailsY + 50 + index * 15);
        });

        // Description
        this.ctx.fillStyle = this.colors.textSecondary;
        this.ctx.font = '8px monospace';
        const words = item.description.split(' ');
        let line = '';
        let y = detailsY + 200;

        words.forEach(word => {
            const testLine = line + word + ' ';
            if (testLine.length > 22 && line !== '') {
                this.ctx.fillText(line, detailsX + 10, y);
                line = word + ' ';
                y += 12;
            } else {
                line = testLine;
            }
        });
        
        if (line !== '') {
            this.ctx.fillText(line, detailsX + 10, y);
        }
    }

    private renderActionButtons(): void {
        if (!this.selectedItem) return;

        const buttonWidth = 180;
        const buttonHeight = 25;
        const buttonX = this.canvas.width - 200;

        // Transfer button
        this.ctx.fillStyle = this.colors.success;
        this.ctx.fillRect(buttonX, this.canvas.height - 120, buttonWidth, buttonHeight);
        
        this.ctx.strokeStyle = this.colors.text;
        this.ctx.strokeRect(buttonX, this.canvas.height - 120, buttonWidth, buttonHeight);

        this.ctx.fillStyle = this.colors.background;
        this.ctx.font = 'bold 10px monospace';
        this.ctx.textAlign = 'center';
        this.ctx.fillText('TRANSFER TO OTHER HOLD', buttonX + buttonWidth / 2, this.canvas.height - 105);

        // Jettison button
        this.ctx.fillStyle = this.colors.danger;
        this.ctx.fillRect(buttonX, this.canvas.height - 80, buttonWidth, buttonHeight);
        
        this.ctx.strokeStyle = this.colors.text;
        this.ctx.strokeRect(buttonX, this.canvas.height - 80, buttonWidth, buttonHeight);

        this.ctx.fillStyle = this.colors.text;
        this.ctx.fillText('JETTISON CARGO', buttonX + buttonWidth / 2, this.canvas.height - 65);
    }

    private renderScanLines(): void {
        this.ctx.strokeStyle = 'rgba(95, 175, 157, 0.1)';
        this.ctx.lineWidth = 1;
        
        for (let y = 0; y < this.canvas.height; y += 4) {
            this.ctx.beginPath();
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(this.canvas.width, y);
            this.ctx.stroke();
        }
    }

    private getFilteredAndSortedItems(): InventoryItem[] {
        const hold = this.cargoHolds.get(this.selectedHold)!;
        let items = Array.from(hold.items.values());

        // Apply filter
        if (this.filter !== 'all') {
            items = items.filter(item => item.category === this.filter);
        }

        // Apply sort
        items.sort((a, b) => {
            switch (this.sortBy) {
                case 'name':
                    return a.name.localeCompare(b.name);
                case 'value':
                    return (b.value * b.quantity) - (a.value * a.quantity);
                case 'mass':
                    return (b.mass * b.quantity) - (a.mass * a.quantity);
                case 'quantity':
                    return b.quantity - a.quantity;
                default:
                    return 0;
            }
        });

        return items;
    }

    private getRarityColor(rarity: ItemRarity): string {
        switch (rarity) {
            case ItemRarity.COMMON: return this.colors.text;
            case ItemRarity.UNCOMMON: return this.colors.success;
            case ItemRarity.RARE: return this.colors.warning;
            case ItemRarity.EPIC: return this.colors.rare;
            case ItemRarity.LEGENDARY: return this.colors.legendary;
            case ItemRarity.ALIEN: return this.colors.accent;
            default: return this.colors.text;
        }
    }

    private getItemById(itemId: string): InventoryItem | null {
        const hold = this.cargoHolds.get(this.selectedHold)!;
        return hold.items.get(itemId) || null;
    }

    private switchToNextHold(): void {
        const holdIds = Array.from(this.cargoHolds.keys());
        const currentIndex = holdIds.indexOf(this.selectedHold);
        const nextIndex = (currentIndex + 1) % holdIds.length;
        this.selectedHold = holdIds[nextIndex];
        this.scrollOffset = 0;
    }

    private transferSelectedItem(): void {
        if (!this.selectedItem) return;

        const item = this.getItemById(this.selectedItem);
        if (!item) return;

        // Show transfer dialog or implement transfer logic
        console.log(`Transferring ${item.name} to another hold`);
    }

    private jettisonSelectedItem(): void {
        if (!this.selectedItem) return;

        const item = this.getItemById(this.selectedItem);
        if (!item) return;

        if (confirm(`Are you sure you want to jettison ${item.quantity}x ${item.name}?`)) {
            this.removeItemFromHold(this.selectedHold, this.selectedItem);
            this.selectedItem = null;
        }
    }

    // Public methods for game integration
    public addItemToHold(holdId: string, item: InventoryItem): boolean {
        const hold = this.cargoHolds.get(holdId);
        if (!hold) return false;

        const totalMass = item.mass * item.quantity;
        const totalVolume = item.volume * item.quantity;

        if (hold.currentMass + totalMass > hold.maxMass ||
            hold.currentVolume + totalVolume > hold.maxVolume) {
            return false;
        }

        if (hold.restrictions.length > 0 && !hold.restrictions.includes(item.category)) {
            return false;
        }

        const existingItem = hold.items.get(item.id);
        if (existingItem && item.stackable) {
            existingItem.quantity += item.quantity;
        } else {
            hold.items.set(item.id, { ...item });
        }

        hold.currentMass += totalMass;
        hold.currentVolume += totalVolume;

        return true;
    }

    public removeItemFromHold(holdId: string, itemId: string, quantity?: number): boolean {
        const hold = this.cargoHolds.get(holdId);
        if (!hold) return false;

        const item = hold.items.get(itemId);
        if (!item) return false;

        const removeQuantity = quantity || item.quantity;
        const removeMass = item.mass * removeQuantity;
        const removeVolume = item.volume * removeQuantity;

        if (removeQuantity >= item.quantity) {
            hold.items.delete(itemId);
        } else {
            item.quantity -= removeQuantity;
        }

        hold.currentMass -= removeMass;
        hold.currentVolume -= removeVolume;

        return true;
    }

    public getCargoValue(holdId?: string): number {
        if (holdId) {
            const hold = this.cargoHolds.get(holdId);
            if (!hold) return 0;
            
            return Array.from(hold.items.values())
                .reduce((total, item) => total + (item.value * item.quantity), 0);
        } else {
            return Array.from(this.cargoHolds.values())
                .reduce((total, hold) => total + this.getCargoValue(hold.id), 0);
        }
    }

    public getCargoMass(holdId?: string): number {
        if (holdId) {
            const hold = this.cargoHolds.get(holdId);
            return hold ? hold.currentMass : 0;
        } else {
            return Array.from(this.cargoHolds.values())
                .reduce((total, hold) => total + hold.currentMass, 0);
        }
    }

    public hasItem(itemId: string, quantity: number = 1): boolean {
        for (const hold of this.cargoHolds.values()) {
            const item = hold.items.get(itemId);
            if (item && item.quantity >= quantity) {
                return true;
            }
        }
        return false;
    }

    public getIsVisible(): boolean {
        return this.isVisible;
    }

    public getSelectedHold(): string {
        return this.selectedHold;
    }
}