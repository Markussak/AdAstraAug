// celestial_bodies.ts - Celestial Body System
import { Vector2 } from ‘./basic_classes’;
import { Renderer } from ‘./renderer’;
import { Camera } from ‘./camera’;
import { GameConfig } from ‘./game_config’;

export interface CelestialBodyData {
name: string;
type: CelestialBodyType;
position: Vector2;
radius: number;
mass: number;
color: string;
rotationSpeed: number;
orbitDistance?: number;
orbitSpeed?: number;
orbitCenter?: Vector2;
atmosphereColor?: string;
hasRings?: boolean;
ringColor?: string;
surfaceFeatures?: SurfaceFeature[];
}

export enum CelestialBodyType {
STAR = ‘star’,
ROCKY_PLANET = ‘rocky_planet’,
GAS_GIANT = ‘gas_giant’,
ICE_PLANET = ‘ice_planet’,
DESERT_PLANET = ‘desert_planet’,
OCEAN_PLANET = ‘ocean_planet’,
VOLCANIC_PLANET = ‘volcanic_planet’,
MOON = ‘moon’,
ASTEROID = ‘asteroid’,
COMET = ‘comet’,
SPACE_STATION = ‘space_station’,
DERELICT = ‘derelict’
}

export interface SurfaceFeature {
type: ‘crater’ | ‘mountain’ | ‘ocean’ | ‘desert’ | ‘ice_cap’ | ‘volcano’ | ‘storm’;
position: Vector2; // Relative to body center
size: number;
color: string;
intensity: number;
}

export class CelestialBody {
public name: string;
public type: CelestialBodyType;
public position: Vector2;
public radius: number;
public mass: number;
public color: string;
public rotation: number;
public rotationSpeed: number;

```
// Orbital mechanics
public orbitDistance: number;
public orbitSpeed: number;
public orbitAngle: number;
public orbitCenter: Vector2;
public isOrbiting: boolean;

// Visual properties
public atmosphereColor: string | null;
public hasRings: boolean;
public ringColor: string;
public surfaceFeatures: SurfaceFeature[];

// Animation properties
private animationTime: number = 0;
private coronaFlicker: number = 0;
private atmosphereShimmer: number = 0;

constructor(data: CelestialBodyData) {
    this.name = data.name;
    this.type = data.type;
    this.position = data.position.clone();
    this.radius = data.radius;
    this.mass = data.mass;
    this.color = data.color;
    this.rotation = Math.random() * Math.PI * 2;
    this.rotationSpeed = data.rotationSpeed;
    
    // Orbital properties
    this.orbitDistance = data.orbitDistance || 0;
    this.orbitSpeed = data.orbitSpeed || 0;
    this.orbitAngle = Math.atan2(this.position.y, this.position.x);
    this.orbitCenter = data.orbitCenter || new Vector2(0, 0);
    this.isOrbiting = this.orbitDistance > 0 && this.orbitSpeed > 0;
    
    // Visual properties
    this.atmosphereColor = data.atmosphereColor || null;
    this.hasRings = data.hasRings || false;
    this.ringColor = data.ringColor || GameConfig.COLORS.HULL_SECONDARY;
    this.surfaceFeatures = data.surfaceFeatures || [];
}

update(deltaTime: number): void {
    this.animationTime += deltaTime;
    
    // Update rotation
    this.rotation += this.rotationSpeed * deltaTime;
    if (this.rotation > Math.PI * 2) {
        this.rotation -= Math.PI * 2;
    }
    
    // Update orbital position
    if (this.isOrbiting) {
        this.orbitAngle += this.orbitSpeed * deltaTime;
        if (this.orbitAngle > Math.PI * 2) {
            this.orbitAngle -= Math.PI * 2;
        }
        
        this.position.x = this.orbitCenter.x + Math.cos(this.orbitAngle) * this.orbitDistance;
        this.position.y = this.orbitCenter.y + Math.sin(this.orbitAngle) * this.orbitDistance;
    }
    
    // Update visual effects
    this.updateVisualEffects(deltaTime);
}

private updateVisualEffects(deltaTime: number): void {
    // Star corona flickering
    if (this.type === CelestialBodyType.STAR) {
        this.coronaFlicker = Math.sin(this.animationTime * 3) * 0.1 + 0.9;
    }
    
    // Atmosphere shimmer for planets with atmospheres
    if (this.atmosphereColor) {
        this.atmosphereShimmer = Math.sin(this.animationTime * 2) * 0.2 + 0.8;
    }
}

render(renderer: Renderer, camera: Camera): void {
    const screenPos = camera.worldToScreen(this.position, renderer.getWidth(), renderer.getHeight());
    
    // Skip rendering if off-screen (with margin)
    const margin = this.radius * 2 + 100;
    if (screenPos.x < -margin || screenPos.x > renderer.getWidth() + margin ||
        screenPos.y < -margin || screenPos.y > renderer.getHeight() + margin) {
        return;
    }

    const scaledRadius = this.radius * camera.zoom;
    
    // Render based on type
    switch (this.type) {
        case CelestialBodyType.STAR:
            this.renderStar(renderer, screenPos, scaledRadius);
            break;
        case CelestialBodyType.GAS_GIANT:
            this.renderGasGiant(renderer, screenPos, scaledRadius);
            break;
        case CelestialBodyType.ASTEROID:
            this.renderAsteroid(renderer, screenPos, scaledRadius);
            break;
        default:
            this.renderPlanet(renderer, screenPos, scaledRadius);
            break;
    }
    
    // Render rings if present
    if (this.hasRings) {
        this.renderRings(renderer, screenPos, scaledRadius);
    }
    
    // Render orbit path if applicable
    if (this.isOrbiting && camera.zoom > 0.3) {
        this.renderOrbitPath(renderer, camera);
    }
    
    // Render label for larger bodies or when zoomed in
    if (scaledRadius > 20 || camera.zoom > 1.0) {
        this.renderLabel(renderer, screenPos, scaledRadius);
    }
}

private renderStar(renderer: Renderer, screenPos: Vector2, radius: number): void {
    // Star corona (outer glow)
    const coronaRadius = radius * (1.5 + this.coronaFlicker * 0.2);
    renderer.drawRadialGradient(
        screenPos.x, screenPos.y,
        radius * 0.7, coronaRadius,
        this.color,
        this.color + '00'
    );
    
    // Main star body
    renderer.drawCircle(screenPos.x, screenPos.y, radius, this.color, true);
    
    // Surface details with dithering
    const ctx = renderer.getContext();
    ctx.save();
    ctx.translate(screenPos.x, screenPos.y);
    ctx.rotate(this.rotation);
    
    // Solar prominences and surface features
    ctx.fillStyle = GameConfig.COLORS.FX_GLOW_SECONDARY;
    ctx.globalAlpha = 0.6;
    
    for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const x = Math.cos(angle) * radius * 0.7;
        const y = Math.sin(angle) * radius * 0.7;
        const featureSize = radius * 0.15;
        
        ctx.beginPath();
        ctx.arc(x, y, featureSize, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // Solar flares (random)
    if (Math.random() < 0.3) {
        ctx.strokeStyle = GameConfig.COLORS.FX_GLOW_SECONDARY;
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.8;
        
        const flareAngle = Math.random() * Math.PI * 2;
        const flareLength = radius + Math.random() * radius * 0.5;
        
        ctx.beginPath();
        ctx.moveTo(Math.cos(flareAngle) * radius, Math.sin(flareAngle) * radius);
        ctx.lineTo(Math.cos(flareAngle) * flareLength, Math.sin(flareAngle) * flareLength);
        ctx.stroke();
    }
    
    ctx.restore();
}

private renderPlanet(renderer: Renderer, screenPos: Vector2, radius: number): void {
    const ctx = renderer.getContext();
    
    // Planet body
    renderer.drawCircle(screenPos.x, screenPos.y, radius, this.color, true);
    
    // Atmosphere if present
    if (this.atmosphereColor) {
        const atmRadius = radius * (1.1 + this.atmosphereShimmer * 0.05);
        ctx.save();
        ctx.globalAlpha = 0.3 * this.atmosphereShimmer;
        renderer.drawCircle(screenPos.x, screenPos.y, atmRadius, this.atmosphereColor, false);
        ctx.restore();
    }
    
    // Surface features
    ctx.save();
    ctx.translate(screenPos.x, screenPos.y);
    ctx.rotate(this.rotation);
    
    this.renderSurfaceFeatures(ctx, radius);
    
    // Day/night terminator
    ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
    ctx.globalAlpha = 0.6;
    ctx.beginPath();
    ctx.arc(0, 0, radius, Math.PI * 0.7, Math.PI * 1.3);
    ctx.fill();
    
    ctx.restore();
}

private renderGasGiant(renderer: Renderer, screenPos: Vector2, radius: number): void {
    const ctx = renderer.getContext();
    
    // Main body
    renderer.drawCircle(screenPos.x, screenPos.y, radius, this.color, true);
    
    ctx.save();
    ctx.translate(screenPos.x, screenPos.y);
    ctx.rotate(this.rotation);
    
    // Atmospheric bands
    const bands = 5 + Math.floor(radius / 20);
    for (let i = 0; i < bands; i++) {
        const bandY = (i / bands - 0.5) * radius * 1.8;
        const bandHeight = radius * 0.2;
        const bandAlpha = 0.3 + (i % 2) * 0.2;
        
        ctx.fillStyle = GameConfig.COLORS.HULL_SECONDARY;
        ctx.globalAlpha = bandAlpha;
        ctx.fillRect(-radius, bandY, radius * 2, bandHeight);
    }
    
    // Great Red Spot or similar storm feature
    if (radius > 30) {
        const stormX = radius * 0.3;
        const stormY = radius * 0.2;
        const stormSize = radius * 0.4;
        
        ctx.fillStyle = GameConfig.COLORS.ACCENT_HOSTILE;
        ctx.globalAlpha = 0.7;
        ctx.beginPath();
        ctx.ellipse(stormX, stormY, stormSize, stormSize * 0.6, 0, 0, Math.PI * 2);
        ctx.fill();
    }
    
    ctx.restore();
}

private renderAsteroid(renderer: Renderer, screenPos: Vector2, radius: number): void {
    const ctx = renderer.getContext();
    
    ctx.save();
    ctx.translate(screenPos.x, screenPos.y);
    ctx.rotate(this.rotation);
    
    // Irregular asteroid shape
    ctx.fillStyle = this.color;
    ctx.beginPath();
    
    const sides = 6 + Math.floor(Math.random() * 4);
    const irregularity = 0.3;
    
    for (let i = 0; i < sides; i++) {
        const angle = (i / sides) * Math.PI * 2;
        const variation = 1 + (Math.random() - 0.5) * irregularity;
        const x = Math.cos(angle) * radius * variation;
        const y = Math.sin(angle) * radius * variation;
        
        if (i === 0) {
            ctx.moveTo(x, y);
        } else {
            ctx.lineTo(x, y);
        }
    }
    ctx.closePath();
    ctx.fill();
    
    // Surface craters and detail
    ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
    for (let i = 0; i < 3; i++) {
        const craterX = (Math.random() - 0.5) * radius * 1.2;
        const craterY = (Math.random() - 0.5) * radius * 1.2;
        const craterSize = radius * 0.1 + Math.random() * radius * 0.2;
        
        ctx.beginPath();
        ctx.arc(craterX, craterY, craterSize, 0, Math.PI * 2);
        ctx.fill();
    }
    
    ctx.restore();
}

private renderSurfaceFeatures(ctx: CanvasRenderingContext2D, radius: number): void {
    this.surfaceFeatures.forEach(feature => {
        ctx.save();
        ctx.fillStyle = feature.color;
        ctx.globalAlpha = feature.intensity;
        
        const featureX = feature.position.x * radius;
        const featureY = feature.position.y * radius;
        const featureSize = feature.size * radius;
        
        switch (feature.type) {
            case 'crater':
                ctx.beginPath();
                ctx.arc(featureX, featureY, featureSize, 0, Math.PI * 2);
                ctx.fill();
                break;
                
            case 'ocean':
                ctx.fillStyle = GameConfig.COLORS.ACCENT_FRIENDLY;
                ctx.fillRect(featureX - featureSize, featureY - featureSize/2, 
                           featureSize * 2, featureSize);
                break;
                
            case 'mountain':
                ctx.fillStyle = GameConfig.COLORS.HULL_SECONDARY;
                ctx.beginPath();
                ctx.moveTo(featureX, featureY - featureSize);
                ctx.lineTo(featureX - featureSize/2, featureY + featureSize/2);
                ctx.lineTo(featureX + featureSize/2, featureY + featureSize/2);
                ctx.closePath();
                ctx.fill();
                break;
                
            case 'ice_cap':
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(featureX, featureY, featureSize, 0, Math.PI * 2);
                ctx.fill();
                break;
        }
        
        ctx.restore();
    });
}

private renderRings(renderer: Renderer, screenPos: Vector2, radius: number): void {
    const ctx = renderer.getContext();
    
    ctx.save();
    ctx.translate(screenPos.x, screenPos.y);
    ctx.rotate(this.rotation * 0.5); // Rings rotate slower
    
    const innerRadius = radius * 1.2;
    const outerRadius = radius * 2.0;
    const ringWidth = outerRadius - innerRadius;
    
    // Multiple ring segments for detail
    for (let i = 0; i < 20; i++) {
        const segmentRadius = innerRadius + (i / 20) * ringWidth;
        const alpha = 0.1 + (i % 3) * 0.1;
        
        ctx.strokeStyle = this.ringColor;
        ctx.globalAlpha = alpha;
        ctx.lineWidth = 1;
        
        ctx.beginPath();
        ctx.arc(0, 0, segmentRadius, 0, Math.PI * 2);
        ctx.stroke();
    }
    
    ctx.restore();
}

private renderOrbitPath(renderer: Renderer, camera: Camera): void {
    const centerScreen = camera.worldToScreen(this.orbitCenter, renderer.getWidth(), renderer.getHeight());
    const orbitRadius = this.orbitDistance * camera.zoom;
    
    if (orbitRadius > 10) { // Only render if orbit is visible
        const ctx = renderer.getContext();
        ctx.save();
        ctx.strokeStyle = GameConfig.COLORS.ACCENT_FRIENDLY;
        ctx.globalAlpha = 0.2;
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        
        ctx.beginPath();
        ctx.arc(centerScreen.x, centerScreen.y, orbitRadius, 0, Math.PI * 2);
        ctx.stroke();
        
        ctx.restore();
    }
}

private renderLabel(renderer: Renderer, screenPos: Vector2, radius: number): void {
    const labelY = screenPos.y + radius + 15;
    const labelColor = GameConfig.COLORS.HULL_PRIMARY;
    
    renderer.drawText(this.name, screenPos.x - (this.name.length * 3), labelY, labelColor, 6);
    
    // Type indicator
    const typeText = this.type.replace('_', ' ').toUpperCase();
    renderer.drawText(typeText, screenPos.x - (typeText.length * 2), labelY + 8, 
                     GameConfig.COLORS.ACCENT_FRIENDLY, 4);
}

// Collision detection
containsPoint(point: Vector2): boolean {
    return this.position.distanceTo(point) <= this.radius;
}

intersects(other: CelestialBody): boolean {
    const distance = this.position.distanceTo(other.position);
    return distance <= (this.radius + other.radius);
}

// Gravitational influence calculation
getGravitationalForce(targetPosition: Vector2, targetMass: number = 1): Vector2 {
    const direction = this.position.subtract(targetPosition);
    const distance = direction.magnitude();
    
    if (distance < this.radius * 2) return new Vector2(0, 0); // Avoid singularities
    
    const force = (this.mass * targetMass * GameConfig.GRAVITATIONAL_CONSTANT) / (distance * distance);
    return direction.normalize().multiply(force);
}

// Utility methods
distanceTo(other: CelestialBody | Vector2): number {
    const otherPos = other instanceof CelestialBody ? other.position : other;
    return this.position.distanceTo(otherPos);
}

isInView(camera: Camera, screenWidth: number, screenHeight: number): boolean {
    return camera.isInView(this.position, this.radius, screenWidth, screenHeight);
}

// Data export for serialization
toData(): CelestialBodyData {
    return {
        name: this.name,
        type: this.type,
        position: this.position.clone(),
        radius: this.radius,
        mass: this.mass,
        color: this.color,
        rotationSpeed: this.rotationSpeed,
        orbitDistance: this.orbitDistance,
        orbitSpeed: this.orbitSpeed,
        orbitCenter: this.orbitCenter.clone(),
        atmosphereColor: this.atmosphereColor || undefined,
        hasRings: this.hasRings,
        ringColor: this.ringColor,
        surfaceFeatures: [...this.surfaceFeatures]
    };
}
```

}

export default CelestialBody;