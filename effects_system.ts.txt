/**
 * Visual Effects System for Space Explorer 16-Bit
 * Handles particle effects, animations, and visual feedback
 */

import { Vector2D } from './basic_classes';

interface Particle {
    position: Vector2D;
    velocity: Vector2D;
    life: number;
    maxLife: number;
    size: number;
    color: string;
    type: string;
    rotation?: number;
    rotationSpeed?: number;
}

interface Effect {
    id: string;
    position: Vector2D;
    life: number;
    maxLife: number;
    type: string;
    particles: Particle[];
    stage: number; // For multi-stage effects like warp
    data?: any; // Additional effect-specific data
}

interface BeamEffect {
    startPos: Vector2D;
    endPos: Vector2D;
    life: number;
    maxLife: number;
    color: string;
    width: number;
    type: string;
}

export class EffectsSystem {
    private effects: Effect[] = [];
    private beams: BeamEffect[] = [];
    private static instance: EffectsSystem;

    // Game color palette
    private static readonly COLORS = {
        HULL_PRIMARY: '#DCD7C9',
        HULL_SECONDARY: '#A27B5C',
        ACCENT_NEUTRAL: '#3F4F44',
        ACCENT_ENERGY: '#F97300',
        SHIELD_BLUE: '#7077A1',
        WEAPON_RED: '#d9626b',
        ENGINE_ORANGE: '#ffc27a',
        WARP_PURPLE: '#a73169',
        EXPLOSION_YELLOW: '#ffeb99',
        SPARK_WHITE: '#ffffff'
    };

    static getInstance(): EffectsSystem {
        if (!this.instance) {
            this.instance = new EffectsSystem();
        }
        return this.instance;
    }

    update(deltaTime: number): void {
        // Update effects
        this.effects = this.effects.filter(effect => {
            effect.life -= deltaTime;
            this.updateEffect(effect, deltaTime);
            return effect.life > 0;
        });

        // Update beams
        this.beams = this.beams.filter(beam => {
            beam.life -= deltaTime;
            return beam.life > 0;
        });
    }

    render(ctx: CanvasRenderingContext2D, camera: { x: number; y: number }): void {
        // Render beams first (behind everything)
        this.renderBeams(ctx, camera);
        
        // Render particle effects
        this.renderEffects(ctx, camera);
    }

    // Weapon Effects
    createLaserBeam(startPos: Vector2D, angle: number, range: number = 400): void {
        const endPos = {
            x: startPos.x + Math.cos(angle) * range,
            y: startPos.y + Math.sin(angle) * range
        };

        this.beams.push({
            startPos: { ...startPos },
            endPos,
            life: 0.1,
            maxLife: 0.1,
            color: EffectsSystem.COLORS.WEAPON_RED,
            width: 2,
            type: 'laser'
        });

        // Add impact sparks at end
        this.createSparks(endPos, 5, EffectsSystem.COLORS.WEAPON_RED);
    }

    createRailgunShot(startPos: Vector2D, angle: number, range: number = 800): void {
        const endPos = {
            x: startPos.x + Math.cos(angle) * range,
            y: startPos.y + Math.sin(angle) * range
        };

        this.beams.push({
            startPos: { ...startPos },
            endPos,
            life: 0.3,
            maxLife: 0.3,
            color: EffectsSystem.COLORS.ACCENT_ENERGY,
            width: 4,
            type: 'railgun'
        });

        // Charging effect at start
        this.createEnergyBurst(startPos, EffectsSystem.COLORS.ACCENT_ENERGY, 10);
    }

    createMissileTrail(position: Vector2D, velocity: Vector2D): void {
        const effect: Effect = {
            id: `missile_trail_${Date.now()}`,
            position: { ...position },
            life: 0.5,
            maxLife: 0.5,
            type: 'missile_trail',
            stage: 0,
            particles: []
        };

        // Create trail particles
        for (let i = 0; i < 3; i++) {
            effect.particles.push({
                position: {
                    x: position.x - velocity.x * 0.1 * i + (Math.random() - 0.5) * 3,
                    y: position.y - velocity.y * 0.1 * i + (Math.random() - 0.5) * 3
                },
                velocity: {
                    x: (Math.random() - 0.5) * 20,
                    y: (Math.random() - 0.5) * 20
                },
                life: 0.3,
                maxLife: 0.3,
                size: 2 + Math.random() * 2,
                color: EffectsSystem.COLORS.ENGINE_ORANGE,
                type: 'smoke'
            });
        }

        this.effects.push(effect);
    }

    // Engine Effects
    createEngineExhaust(position: Vector2D, angle: number, thrust: number): void {
        if (thrust <= 0.1) return;

        const effect: Effect = {
            id: `engine_${Date.now()}`,
            position: { ...position },
            life: 0.2,
            maxLife: 0.2,
            type: 'engine_exhaust',
            stage: 0,
            particles: []
        };

        const particleCount = Math.floor(thrust * 8);
        
        for (let i = 0; i < particleCount; i++) {
            const spreadAngle = angle + Math.PI + (Math.random() - 0.5) * 0.5;
            const speed = 50 + Math.random() * 100 * thrust;
            
            effect.particles.push({
                position: {
                    x: position.x + Math.cos(angle + Math.PI) * 12,
                    y: position.y + Math.sin(angle + Math.PI) * 12
                },
                velocity: {
                    x: Math.cos(spreadAngle) * speed,
                    y: Math.sin(spreadAngle) * speed
                },
                life: 0.3 + Math.random() * 0.2,
                maxLife: 0.5,
                size: 1 + Math.random() * 3,
                color: i < particleCount * 0.6 ? 
                    EffectsSystem.COLORS.ACCENT_ENERGY : 
                    EffectsSystem.COLORS.ENGINE_ORANGE,
                type: 'exhaust'
            });
        }

        this.effects.push(effect);
    }

    // Shield Effects
    createShieldHit(position: Vector2D, impactAngle: number): void {
        const effect: Effect = {
            id: `shield_hit_${Date.now()}`,
            position: { ...position },
            life: 0.5,
            maxLife: 0.5,
            type: 'shield_hit',
            stage: 0,
            particles: []
        };

        // Create energy ripple particles
        for (let i = 0; i < 12; i++) {
            const angle = (i / 12) * Math.PI * 2;
            const distance = 10 + Math.random() * 15;
            
            effect.particles.push({
                position: {
                    x: position.x + Math.cos(angle) * distance,
                    y: position.y + Math.sin(angle) * distance
                },
                velocity: {
                    x: Math.cos(angle) * 30,
                    y: Math.sin(angle) * 30
                },
                life: 0.4,
                maxLife: 0.4,
                size: 2 + Math.random() * 2,
                color: EffectsSystem.COLORS.SHIELD_BLUE,
                type: 'energy'
            });
        }

        this.effects.push(effect);
    }

    createShieldFlow(shipPosition: Vector2D, shipAngle: number, shieldStrength: number): void {
        if (shieldStrength <= 0) return;

        const effect: Effect = {
            id: `shield_flow_${Date.now()}`,
            position: { ...shipPosition },
            life: 0.1,
            maxLife: 0.1,
            type: 'shield_flow',
            stage: 0,
            particles: [],
            data: { shipAngle, shieldStrength }
        };

        // Create flowing energy particles around ship
        const particleCount = Math.floor(shieldStrength * 0.15);
        for (let i = 0; i < particleCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = 18 + Math.random() * 5;
            
            effect.particles.push({
                position: {
                    x: shipPosition.x + Math.cos(angle) * radius,
                    y: shipPosition.y + Math.sin(angle) * radius
                },
                velocity: {
                    x: Math.cos(angle + Math.PI * 0.5) * 20,
                    y: Math.sin(angle + Math.PI * 0.5) * 20
                },
                life: 0.8,
                maxLife: 0.8,
                size: 1,
                color: EffectsSystem.COLORS.SHIELD_BLUE,
                type: 'shield_flow'
            });
        }

        this.effects.push(effect);
    }

    // Warp Drive Effects
    createWarpCharging(position: Vector2D): void {
        const effect: Effect = {
            id: `warp_charging_${Date.now()}`,
            position: { ...position },
            life: 2.0,
            maxLife: 2.0,
            type: 'warp_charging',
            stage: 0,
            particles: []
        };

        this.effects.push(effect);
    }

    createWarpActivation(position: Vector2D): void {
        const effect: Effect = {
            id: `warp_activation_${Date.now()}`,
            position: { ...position },
            life: 3.0,
            maxLife: 3.0,
            type: 'warp_activation',
            stage: 0,
            particles: []
        };

        this.effects.push(effect);
    }

    createWarpTravel(position: Vector2D): void {
        const effect: Effect = {
            id: `warp_travel_${Date.now()}`,
            position: { ...position },
            life: 0.5,
            maxLife: 0.5,
            type: 'warp_travel',
            stage: 0,
            particles: []
        };

        // Create space distortion particles
        for (let i = 0; i < 20; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = 30 + Math.random() * 40;
            
            effect.particles.push({
                position: {
                    x: position.x + Math.cos(angle) * distance,
                    y: position.y + Math.sin(angle) * distance
                },
                velocity: {
                    x: Math.cos(angle) * -100,
                    y: Math.sin(angle) * -100
                },
                life: 0.3,
                maxLife: 0.3,
                size: 1 + Math.random() * 2,
                color: EffectsSystem.COLORS.WARP_PURPLE,
                type: 'space_distortion'
            });
        }

        this.effects.push(effect);
    }

    // Explosion Effects
    createExplosion(position: Vector2D, size: number = 1.0): void {
        const effect: Effect = {
            id: `explosion_${Date.now()}`,
            position: { ...position },
            life: 1.0,
            maxLife: 1.0,
            type: 'explosion',
            stage: 0,
            particles: []
        };

        const particleCount = Math.floor(15 * size);
        
        for (let i = 0; i < particleCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 20 + Math.random() * 80 * size;
            
            effect.particles.push({
                position: { ...position },
                velocity: {
                    x: Math.cos(angle) * speed,
                    y: Math.sin(angle) * speed
                },
                life: 0.5 + Math.random() * 0.5,
                maxLife: 1.0,
                size: 2 + Math.random() * 4 * size,
                color: i < particleCount * 0.4 ? 
                    EffectsSystem.COLORS.EXPLOSION_YELLOW : 
                    EffectsSystem.COLORS.ENGINE_ORANGE,
                type: 'explosion_debris'
            });
        }

        this.effects.push(effect);
    }

    // Utility Effects
    createSparks(position: Vector2D, count: number = 8, color: string = '#ffffff'): void {
        const effect: Effect = {
            id: `sparks_${Date.now()}`,
            position: { ...position },
            life: 0.3,
            maxLife: 0.3,
            type: 'sparks',
            stage: 0,
            particles: []
        };

        for (let i = 0; i < count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 30 + Math.random() * 50;
            
            effect.particles.push({
                position: { ...position },
                velocity: {
                    x: Math.cos(angle) * speed,
                    y: Math.sin(angle) * speed
                },
                life: 0.2 + Math.random() * 0.2,
                maxLife: 0.4,
                size: 1,
                color: color,
                type: 'spark'
            });
        }

        this.effects.push(effect);
    }

    createEnergyBurst(position: Vector2D, color: string, intensity: number = 5): void {
        const effect: Effect = {
            id: `energy_burst_${Date.now()}`,
            position: { ...position },
            life: 0.6,
            maxLife: 0.6,
            type: 'energy_burst',
            stage: 0,
            particles: []
        };

        for (let i = 0; i < intensity; i++) {
            const angle = (i / intensity) * Math.PI * 2 + Math.random() * 0.5;
            
            effect.particles.push({
                position: { ...position },
                velocity: {
                    x: Math.cos(angle) * 40,
                    y: Math.sin(angle) * 40
                },
                life: 0.4,
                maxLife: 0.4,
                size: 2 + Math.random() * 2,
                color: color,
                type: 'energy'
            });
        }

        this.effects.push(effect);
    }

    // Private update methods
    private updateEffect(effect: Effect, deltaTime: number): void {
        // Update all particles in effect
        effect.particles = effect.particles.filter(particle => {
            particle.position.x += particle.velocity.x * deltaTime;
            particle.position.y += particle.velocity.y * deltaTime;
            particle.life -= deltaTime;

            if (particle.rotation !== undefined && particle.rotationSpeed !== undefined) {
                particle.rotation += particle.rotationSpeed * deltaTime;
            }

            // Apply particle-specific updates
            this.updateParticle(particle, deltaTime);

            return particle.life > 0;
        });

        // Update effect-specific logic
        switch (effect.type) {
            case 'warp_charging':
                this.updateWarpCharging(effect, deltaTime);
                break;
            case 'warp_activation':
                this.updateWarpActivation(effect, deltaTime);
                break;
            case 'shield_flow':
                this.updateShieldFlow(effect, deltaTime);
                break;
        }
    }

    private updateParticle(particle: Particle, deltaTime: number): void {
        // Apply gravity/drag based on particle type
        switch (particle.type) {
            case 'smoke':
            case 'exhaust':
                particle.velocity.x *= 0.95;
                particle.velocity.y *= 0.95;
                break;
            case 'explosion_debris':
                particle.velocity.x *= 0.98;
                particle.velocity.y *= 0.98;
                break;
            case 'space_distortion':
                // Particles accelerate toward center during warp
                const centerForce = 50;
                const dx = 0 - (particle.position.x - particle.position.x);
                const dy = 0 - (particle.position.y - particle.position.y);
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance > 0) {
                    particle.velocity.x += (dx / distance) * centerForce * deltaTime;
                    particle.velocity.y += (dy / distance) * centerForce * deltaTime;
                }
                break;
        }
    }

    private updateWarpCharging(effect: Effect, deltaTime: number): void {
        const progress = 1 - (effect.life / effect.maxLife);
        
        if (progress > 0.3 && effect.particles.length < 50) {
            // Add vacuum particles
            for (let i = 0; i < 3; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = 40 + Math.random() * 60;
                
                effect.particles.push({
                    position: {
                        x: effect.position.x + Math.cos(angle) * distance,
                        y: effect.position.y + Math.sin(angle) * distance
                    },
                    velocity: {
                        x: Math.cos(angle) * -30,
                        y: Math.sin(angle) * -30
                    },
                    life: 1.0,
                    maxLife: 1.0,
                    size: 1 + Math.random(),
                    color: EffectsSystem.COLORS.WARP_PURPLE,
                    type: 'warp_vacuum'
                });
            }
        }
    }

    private updateWarpActivation(effect: Effect, deltaTime: number): void {
        const progress = 1 - (effect.life / effect.maxLife);
        
        // Stage 0: Vacuum effect (0-0.3)
        // Stage 1: Black dot formation (0.3-0.5)
        // Stage 2: Black hole growth (0.5-0.8)
        // Stage 3: Accretion disk and space curvature (0.8-1.0)
        
        if (progress < 0.3) {
            effect.stage = 0;
        } else if (progress < 0.5) {
            effect.stage = 1;
        } else if (progress < 0.8) {
            effect.stage = 2;
        } else {
            effect.stage = 3;
        }
    }

    private updateShieldFlow(effect: Effect, deltaTime: number): void {
        // Continuously generate flowing particles
        if (effect.data && effect.data.shieldStrength > 0) {
            const particleCount = Math.floor(effect.data.shieldStrength * 0.1);
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 18 + Math.random() * 3;
                
                effect.particles.push({
                    position: {
                        x: effect.position.x + Math.cos(angle) * radius,
                        y: effect.position.y + Math.sin(angle) * radius
                    },
                    velocity: {
                        x: Math.cos(angle + Math.PI * 0.5) * 15,
                        y: Math.sin(angle + Math.PI * 0.5) * 15
                    },
                    life: 0.6,
                    maxLife: 0.6,
                    size: 1,
                    color: EffectsSystem.COLORS.SHIELD_BLUE,
                    type: 'shield_flow'
                });
            }
        }
    }

    // Rendering methods
    private renderBeams(ctx: CanvasRenderingContext2D, camera: { x: number; y: number }): void {
        this.beams.forEach(beam => {
            const alpha = beam.life / beam.maxLife;
            ctx.globalAlpha = alpha;
            
            ctx.strokeStyle = beam.color;
            ctx.lineWidth = beam.width;
            
            if (beam.type === 'railgun') {
                // Add glow effect for railgun
                ctx.shadowColor = beam.color;
                ctx.shadowBlur = 10;
            }
            
            ctx.beginPath();
            ctx.moveTo(beam.startPos.x - camera.x, beam.startPos.y - camera.y);
            ctx.lineTo(beam.endPos.x - camera.x, beam.endPos.y - camera.y);
            ctx.stroke();
            
            ctx.shadowBlur = 0;
        });
        
        ctx.globalAlpha = 1.0;
    }

    private renderEffects(ctx: CanvasRenderingContext2D, camera: { x: number; y: number }): void {
        this.effects.forEach(effect => {
            if (effect.type === 'warp_activation') {
                this.renderWarpActivation(ctx, camera, effect);
            } else {
                this.renderParticleEffect(ctx, camera, effect);
            }
        });
    }

    private renderParticleEffect(ctx: CanvasRenderingContext2D, camera: { x: number; y: number }, effect: Effect): void {
        effect.particles.forEach(particle => {
            const screenX = particle.position.x - camera.x;
            const screenY = particle.position.y - camera.y;
            
            const alpha = particle.life / particle.maxLife;
            ctx.globalAlpha = alpha;
            ctx.fillStyle = particle.color;
            
            if (particle.type === 'energy' || particle.type === 'shield_flow') {
                // Add glow for energy particles
                ctx.shadowColor = particle.color;
                ctx.shadowBlur = 3;
            }
            
            ctx.fillRect(screenX - particle.size/2, screenY - particle.size/2, 
                        particle.size, particle.size);
            
            ctx.shadowBlur = 0;
        });
        
        ctx.globalAlpha = 1.0;
    }

    private renderWarpActivation(ctx: CanvasRenderingContext2D, camera: { x: number; y: number }, effect: Effect): void {
        const screenX = effect.position.x - camera.x;
        const screenY = effect.position.y - camera.y;
        const progress = 1 - (effect.life / effect.maxLife);
        
        ctx.save();
        ctx.translate(screenX, screenY);
        
        switch (effect.stage) {
            case 0: // Vacuum effect
                this.renderParticleEffect(ctx, { x: 0, y: 0 }, effect);
                break;
                
            case 1: // Black dot formation
                ctx.fillStyle = '#000000';
                const dotSize = progress * 4;
                ctx.fillRect(-dotSize/2, -dotSize/2, dotSize, dotSize);
                break;
                
            case 2: // Black hole growth
                const holeSize = (progress - 0.5) * 40;
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(0, 0, holeSize, 0, Math.PI * 2);
                ctx.fill();
                break;
                
            case 3: // Accretion disk and space curvature
                const diskSize = (progress - 0.8) * 60;
                
                // Accretion disk
                const gradient = ctx.createRadialGradient(0, 0, diskSize * 0.3, 0, 0, diskSize);
                gradient.addColorStop(0, 'rgba(167, 49, 105, 0)');
                gradient.addColorStop(0.7, 'rgba(167, 49, 105, 0.6)');
                gradient.addColorStop(1, 'rgba(249, 115, 0, 0.8)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, diskSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Central black hole
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(0, 0, diskSize * 0.3, 0, Math.PI * 2);
                ctx.fill();
                break;
        }
        
        ctx.restore();
    }

    // Public cleanup method
    clearAllEffects(): void {
        this.effects = [];
        this.beams = [];
    }
}